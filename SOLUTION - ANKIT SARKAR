   Understanding
->Input: GPS data from a u-blox GNSS receiver in UBX binary format (not NMEA), a start and goal pose on a grid map (obstacles vs free cells), and wheel/drive parameters for the rover.
->	Output:
1.	Correct latitude & longitude decoded from UBX;
2.	An optimal path across the grid (obstacle-aware);
3.	Odometry/motion commands (turn + drive with timing) that the rover can execute;
4.	End-to-end build and check.
    Thought Process
1.	UBX decoding: Lock onto UBX sync (0xB5 0x62), verify class/id for NAV-PVT (0x01/0x07), validate length and checksum, then read lon/lat as signed 32-bit integers in 1e-7 degrees (little-endian). Convert to double degrees.
2.	Path planning: Use A* on a 2D grid. For 4-connected motion, use Manhattan heuristic; for 8-connected (if allowed), use octile heuristic. Reconstruct path by backpointers.
3.	Odometry: Convert the polyline path into a sequence of (rotate → go-straight) segments. From consecutive points: compute target heading, heading delta, straight-line distance, then time via max_angular_speed and max_linear_speed. Keep per-segment commands and totals (total turn angle, total time, total distance).
4.	Testing:
UBX: feed known NAV-PVT frames; compare decoded lat/lon with truth.
Planner: small fixtures with known shortest paths.
Odometry: simple L-shapes to verify timing and angles.
   Implementation
UBX Decoding – Implemented parser for UBX NAV-PVT messages to extract accurate latitude & longitude after checksum validation.
Path Planning – Used A* algorithm on the grid map to compute the shortest path from start to goal while avoiding obstacles.
Odometry Commands – Converted path into rotation and drive commands with timing based on rover wheel parameters.
Testing & Compilation – Verified correctness using make build and make check, ensuring end-to-end workflow runs successfully.

